From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Owen1212055 <23108066+Owen1212055@users.noreply.github.com>
Date: Fri, 29 Jul 2022 20:08:37 -0400
Subject: [PATCH] PaperPR Add more collision code skipping logic

https://github.com/PaperMC/Paper/pull/7581
Skips pushEntities logic if:
The entity cannot collide in the first place
The entity is on a team that can never collide (this does a hashmap call, but should return null in most instances)
This logic was stolen from the pushable predicate, wherein cases that were independent of the entity that is being pushed would return false.
For example, the predicate checks if !entity.canCollideWithBukkit(entity1) which leads to the isCollidable method, so we can confirm that we can move it to the front here.

diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index 8800f2ab9e43a0377c1eae1f735bf3c5a09c8a36..2fe0316f02ed60ccd372421049e08ad18701a277 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -3577,6 +3577,10 @@ public abstract class LivingEntity extends Entity {
 
     protected void pushEntities() {
         // Paper start - don't run getEntities if we're not going to use its result
+        if (!this.isPushable()) return;
+        net.minecraft.world.scores.Team team = this.getTeam();
+        if (team != null && team.getCollisionRule() == net.minecraft.world.scores.Team.CollisionRule.NEVER) return;
+
         int i = this.level.getGameRules().getInt(GameRules.RULE_MAX_ENTITY_CRAMMING);
         if (i <= 0 && level.paperConfig().collisions.maxEntityCollisions <= 0) {
             return;
